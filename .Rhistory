LogPWL.total(beta=beta,alpha=alpha,rho=rho,x,u=u, maxlag=3)
#############
nll.ou.total<- function(theta, x, u){
beta<- theta[1]
alpha<- theta[2]
rho<- theta[3]
# check the parameter space !
v<- -LogPWL.total(beta,alpha,rho,x,u, maxlag=1)
# v<- -LogPWL.g(beta=beta, alpha=alpha,rho=rho, x1=x1, x2=x2,u1=u1,u2=u2)
print(c(v,theta))
return(v)
}
parm<- c(199,29,0.8)
lower<- c(1e-6,1e-6,1e-6)
upper<- c(600, 600, 1-1e-6)
fit.ou<- optim(par=parm, fn=nll.ou.total,  gr=NULL, lower=lower, upper=upper,
method=c("L-BFGS-B"), hessian=TRUE,
control=list(maxit=2000), x=x,u=u)
fit.ou
round(fit.ou$par,2)
rho=0.85
alpha=30
beta1=1
Lambda<-gam.ou.pro(alpha=alpha, beta1=beta1,rho=rho,T=30000)$X ##Latent layer Generated from gamma process
beta<- 200
q<- 1-exp(-Lambda/beta) #
x<- rgeom(30000, q) #  Discrete time series data with gamma latent layer
plot(table(x), ylab="Frequency" ,xlab = expression(x[t]))
######## Threshold ##################
#mrlplot(x, u.range = c(1, quantile(x, probs = 0.99999)),
#        col = c("purple", "black", "purple"), nt = 200)
u=quantile(x, probs = 0.95, na.rm = FALSE,
names = TRUE, type = 7)
#abline(v=u, col="red")
##################Laplace transforms ####################
########################## Gaver and Lewis (1980)#############
lt.1 <- function(x, beta, alpha)
{
b<- (beta/ (beta + x))^alpha
return(b)
}
lt.2 <- function(x1,x2,beta, alpha, rho)
{
a1<- (x1+x2)/beta
a2<- (x1*x2*(1-rho))/(beta*beta)
a<- (1/(1+a1+a2))^(alpha)
return(a)
}
LogPWL.ou=function(beta,alpha,rho,x1,x2,u1, u2){
llik= 0
sel<- (x1> u1 & x2>u2)
if (sum(sel)>0){
A=lt.2(x1[sel],x2[sel],beta, alpha, rho)- lt.2(x1[sel],x2[sel]+1,beta, alpha, rho)-
lt.2(x1[sel]+1,x2[sel],beta, alpha, rho) +lt.2(x1[sel]+1,x2[sel]+1,beta, alpha, rho)
llik= llik+sum(log(A))
}
sel<- (x1>u1 & x2 <= u2)
if (sum(sel)>0){
u2.tmp<-rep(u2,sum(sel))
B= lt.1(x=x1[sel], beta, alpha) - lt.1(x=x1[sel]+1, beta, alpha) +
lt.2(x1[sel]+1,u2.tmp+1,beta, alpha, rho) - lt.2(x1[sel],u2.tmp+1,beta, alpha, rho)
llik= llik+sum(log(B))
}
sel<-(x1<= u1 & x2>u2)
if (sum(sel)>0){
u1.tmp<-rep(u1,sum(sel))
C= lt.1(x=x2[sel], beta, alpha) - lt.1(x=x2[sel]+1, beta, alpha) +
lt.2(u1.tmp+1,x2[sel]+1,beta, alpha, rho) - lt.2(u1.tmp+1,x2[sel],beta, alpha, rho)
llik= llik+sum(log(C))
}
sel<-(x1<=u1 & x2<=u2)
if (sum(sel)>0){
D = 1- lt.1(x=u1+1, beta, alpha) - lt.1(x=u2+1, beta, alpha) +
lt.2(u1+1,u2+1,beta, alpha, rho)
llik= llik+sum(sel)*log(D)
}
return(llik)
}
LogPWL.total<-function(beta,alpha,rho,x,u, maxlag=NULL){
v<-0
n<-length(x)
for (k in 1:maxlag) {
v<- v+LogPWL.ou(beta,alpha,rho^k,x1=x[1:(n-k)],x2=x[(k+1):n],u1=u, u2=u)
}
return(v)
}
LogPWL.total(beta=beta,alpha=alpha,rho=rho,x,u=u, maxlag=3)
#############
nll.ou.total<- function(theta, x, u){
beta<- theta[1]
alpha<- theta[2]
rho<- theta[3]
# check the parameter space !
v<- -LogPWL.total(beta,alpha,rho,x,u, maxlag=1)
# v<- -LogPWL.g(beta=beta, alpha=alpha,rho=rho, x1=x1, x2=x2,u1=u1,u2=u2)
print(c(v,theta))
return(v)
}
parm<- c(199,29,0.8)
lower<- c(1e-6,1e-6,1e-6)
upper<- c(600, 600, 1-1e-6)
fit.ou<- optim(par=parm, fn=nll.ou.total,  gr=NULL, lower=lower, upper=upper,
method=c("L-BFGS-B"), hessian=TRUE,
control=list(maxit=2000), x=x,u=u)
fit.ou
round(fit.ou$par,2)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
source("D:/PHD WORK/R Code for PhD work/Simulation codes/PWL Time/PWL OU proce.R", echo=TRUE)
setwd("D:/DEVGAM/evgam-master/")
dest <- "./R/"
files = list.files(dest, full.names = T)
for (i in 1:length(files)) {
source(files[i])
}
dest <- "./src/"
files = list.files(dest, full.names = T)
for (i in 1:length(files)) {
Rcpp::sourceCpp(files[i])
}
################DEGPD1
library(mev)
###  Real application--------------------------------
setwd("D:/PHD WORK/R Code for PhD work/Discrete Extended GPD/Custom likelihood/Real Applications/EVGAM DEGPD")
path = "" #"C:\\..." # to be completed
source(paste(path,"degpd_pack.r",sep =""))
data <- read.csv("Massif4_movsum.csv")
head(data)
data<-data.frame(data)
inits1<- c(3.0896946, 0.1762738, 0.2)
fmla_degpd1 <- list(lsigma = N_SUM ~s(WS10M_MAX_ME, k=5)+s(T2M_MAX_ME, k=5)+s(PREC_ME, k=5)+s(RH2M_ME, bs="cr"), lxi = ~1, lkappa = ~1)
m_degpd1<- devgam(fmla_degpd1, data = data, family = "degpd",degpd.args = list(m=1), trace = 2, inits = inits1)
summary(m_degpd1)
est_par =predict(m_degpd1, type = 'response')
head(est_par)
plot(m_degpd1)
AIC(m_degpd1)
BIC(m_degpd1)
q_degpd1<-predict(m_degpd1,  prob = c(0.99,0.9966667))
boxplot(q_degpd1)
q_degpd1<-predict(m_degpd1,  prob = c(0.99))
boxplot(q_degpd1)
mean(q_degpd1$`q:0.99`)
par(mfrow=c(2,1))
library(extRemes)
library(rcompanion)
u=runif(length(data$N_SUM))
y=data$N_SUM
r<- (1-u)*pdegpd(y-1, kappa = est_par$kappa,sigma = est_par$scale, xi = est_par$shape, type = 1) + u*pdegpd(y, kappa = est_par$kappa,sigma = est_par$scale, xi = est_par$shape, type = 1)
v=qnorm(r)
par(mar = c(4, 4, 2, 0.5))
plotNormalHistogram( v, prob = TRUE,
main = "Histogram and Density \n Estimate of Residuals",
length = 1000, xlab="Quantile Residuals",linecol = "blue")
qqnorm(v, main="Normal Q-Q plot", xlab = "Theoretical Quantiles");qqline(v,col="red")
######### DGPD
#library(GJRM)
form.DGPD <- list(N_SUM ~ 1, ~s(WS10M_MAX_ME, k=5)+s(T2M_MAX_ME, k=5)+s(PREC_ME, k=5)+s(RH2M_ME, bs="cr"))
# Classical fit
############################################################
DGPD.classical <- gamlss(form.DGPD, margin = "DGPII", data = data)
library(GJRM)
######### DGPD
#library(GJRM)
form.DGPD <- list(N_SUM ~ 1, ~s(WS10M_MAX_ME, k=5)+s(T2M_MAX_ME, k=5)+s(PREC_ME, k=5)+s(RH2M_ME, bs="cr"))
# Classical fit
############################################################
DGPD.classical <- gamlss(form.DGPD, margin = "DGPII", data = data)
conv.check(DGPD.classical)
source(paste(path,"post check.r",sep =""))
post.check(DGPD.classical)
summary(DGPD.classical)
plot(DGPD.classical, eq = 2, all.terms = TRUE, pages = 1, main="DGPD")
DGPD.AIC <- AIC(DGPD.classical)
DGPD.BIC <- BIC(DGPD.classical)
DGPD.AIC
DGPD.BIC
###Real Application-----------------------------------
inits1 <- c(0.95, 0.1961042, .25, 0.20, 0.20)
fmla_degpd2 <- list(lsigma = N_SUM ~s(WS10M_MAX_ME, k=5)+s(T2M_MAX_ME, k=5)+s(PREC_ME, k=5)+s(RH2M_ME, bs="cr"), lxi = ~1, lkappa1 = ~ 1, lkappa2 = ~ 1, logitp = ~1)
m_degpd2<- devgam(fmla_degpd2, data = data, family = "degpd",degpd.args = list(m=2), trace = 2, inits = inits1)
summary(m_degpd2)
est_par =predict(m_degpd2, type = 'response')
head(est_par)
plot(m_degpd2)
par(mfrow=c(2,1))
##Real applications-------------------------
inits1 <- c(1.0108917, 0.2010064, 0.9564968)
fmla_degpd3 <- list(lsigma = N_SUM ~s(WS10M_MAX_ME, k=5)+s(T2M_MAX_ME, k=5)+s(PREC_ME, k=5)+s(RH2M_ME, bs="cr"), lxi = ~1, ldelta = ~1)
m_degpd3<- devgam(fmla_degpd3, data = data, family = "degpd",degpd.args = list(m=3), trace = 2, inits = inits1)
summary(m_degpd3)
est_par =predict(m_degpd3, type = 'response')
head(est_par)
plot(m_degpd3)
AIC(m_degpd3)
BIC(m_degpd3)
###  Real application--------------------------------
setwd("D:/PHD WORK/R Code for PhD work/Discrete Extended GPD/Custom likelihood/Real Applications/EVGAM DEGPD")
path = "" #"C:\\..." # to be completed
source(paste(path,"degpd_pack.r",sep =""))
data <- read.csv("Massif4_movsum.csv")
head(data)
data<-data.frame(data)
inits1<- c(3.0896946, 0.1762738, 0.2)
fmla_degpd1 <- list(lsigma = N_SUM ~s(WS10M_MAX_ME, k=5)+s(T2M_MAX_ME, k=5)+s(PREC_ME, k=5)+s(RH2M_ME, bs="cr"), lxi = ~1, lkappa = ~1)
m_degpd1<- devgam(fmla_degpd1, data = data, family = "degpd",degpd.args = list(m=1), trace = 2, inits = inits1)
summary(m_degpd1)
est_par =predict(m_degpd1, type = 'response')
head(est_par)
plot(m_degpd1)
AIC(m_degpd1)
BIC(m_degpd1)
q_degpd1<-predict(m_degpd1,  prob = c(0.99))
q_degpd1
plot(q_degpd1)
str(q_degpd1)
boxplot(q_degpd1)
mean(q_degpd1$`q:0.99`)
m_degpd1$coefficients
m_degpd1$coefficients
######### DGPD
#library(GJRM)
form.DGPD <- list(N_SUM ~ 1, ~s(WS10M_MAX_ME, k=5)+s(T2M_MAX_ME, k=5)+s(PREC_ME, k=5)+s(RH2M_ME, bs="cr"))
# Classical fit
############################################################
DGPD.classical <- gamlss(form.DGPD, margin = "DGPII", data = data)
conv.check(DGPD.classical)
source(paste(path,"post check.r",sep =""))
DGPD.classical$coefficients
DGPD.classical$Vb
m_degpd1$Vlsp
m_degpd1$Vp
m_degpd1$Vc
m_degpd1$data
m_degpd1$Vp
DGPD.classical$X2
m_degpd1$Vp
predict(m_degpd1)
pars<- exp(predict(m_degpd1))
pars[1]
pars[2]
pars[3]
pars$logscale
sigma <- exp( predict(DGPD.classical, eq = 2) )
sigma
DGPD.classical$X1.d2
1:DGPD.classical$X1.d2
X1m  <- predict(DGPD.classical, eq = 1,                    type = "lpmatrix")
X1m
View(X1m)
X2m  <- predict(DGPD.classical, eq = 2,                    type = "lpmatrix")
X2m
X2m  <- predict(m_degpd1,                  type = "lpmatrix")
X2m
X2m  <- predict(m_degpd1,eq=1                  type = "lpmatrix")
X2m  <- predict(m_degpd1,                  type = "lpmatrix")
X2m$logscale
X2m$logshape
X2m$logkappa
DGPD.classical$X1.d2
DGPD.classical$X1.d2
(DGPD.classical$X1.d2 + 1):(DGPD.classical$X1.d2 + DGPD.classical$X2.d2)
DGPD.classical$X1.d2 + DGPD.classical$X2.d2
DGPD.classical$X2.d2
Xs  <- predict(m_degpd1, type = "lpmatrix")
m_degpd1$nobs
m_degpd1$sp
m_degpd1$idpars
m_degpd1$call
m_degpd1$ngam
m_degpd1$plotdata
m_degpd1$compacted
m_degpd1$formula
m_degpd1$Sdata
(DGPD.classical$X1.d2 + 1):(DGPD.classical$X1.d2 + DGPD.classical$X2.d2)
2:23
pred.gp <- function(x, p = 0.5, newdata, n.sim = 100, prob.lev = 0.05){
qp <- CIqp <- sigma <- xi <- kappa<-  CIsigma <- CIxi<- CIkappa <- NULL
#mar <- x$margins[1]
bs  <- rMVN(n.sim, mean = x$coefficients, sigma = x$Vp)
if(!missing(newdata)){
#  if(mar %in% c("GPII","GPo") ) xi <- exp( predict(x, eq = 1, newdata = newdata) ) - 0.5
#  if(mar %in% c("GP","DGP") )   xi <-      predict(x, eq = 1, newdata = newdata)
pars <- exp(predict(x, newdata = newdata)) # predict(x, eq = 1, newdata = newdata)^2
sigma<- pars$logscale
xi<- pars$logshape
kappa<- pars$logkappa
}
if(missing(newdata)){
pars <- exp(predict(x)) # predict(x, eq = 1, newdata = newdata)^2
sigma<- pars$logscale
xi<- pars$logshape
kappa<- pars$logkappa
}
# the above can be made more efficient by creating a function that carries out
# the transformations
###########
###########
q.p <-qdegpd(p, kappa = kappa, sigma = sigma, xi=xi, type=1)
###########
# INTERVALS
###########
ind1 <- 1
if(!missing(newdata)) Xs  <- predict(x, newdata = newdata, type = "lpmatrix")
X1m <- Xs$logscale
X2m <- Xs$logshape
X3m <- Xs$logkappa
if( missing(newdata)) Xs  <- predict(x,                    type = "lpmatrix")
X1m <- Xs$logscale
X2m <- Xs$logshape
X3m <- Xs$logkappa
#ind2 <- (x$X1.d2 + 1):(x$X1.d2 + x$X2.d2)
ind2<- 2:23
eta1S <- X1m%*%t(bs[, ind2])
eta2S <- X2m%*%t(bs[, ind1])
eta3S <- X3m%*%t(bs[, ind1])
sigmaS <- exp( eta1S )
xiS <- exp( eta2S )
kappaS <- exp( eta3S ) #      eta1S^2
q.pS <- qdegpd(p, kappa = kappaS, sigma = sigmaS, xi=xiS, type=1)
CIqp  <- rowQuantiles(q.pS,   probs = c(prob.lev/2, 1-prob.lev/2), na.rm = TRUE)
CIsigma <- rowQuantiles(sigmaS, probs = c(prob.lev/2, 1-prob.lev/2), na.rm = TRUE)
CIxi  <- rowQuantiles(xiS,    probs = c(prob.lev/2, 1-prob.lev/2), na.rm = TRUE)
CIkappa  <- rowQuantiles(kappaS,    probs = c(prob.lev/2, 1-prob.lev/2), na.rm = TRUE)
list(qp = q.p, CIqp = CIqp, xi = xi , sigma = sigma,kappa=kappa,  CIsigma = CIsigma,CIxi = CIxi,CIkappa = CIkappa)
}
library(GJRM)
n.size <- 250
x1 <- rnorm(n.size)
x2 <- rnorm(n.size)
x3 <- rnorm(n.size)
XX <- data.frame(x1 = x1, x2 = x2, x3 = x3)
Xmat <- model.matrix( ~ x1 + x2 + x3)
##############################################################################
# D-GPD (discrete case)
##############################################################################
set.seed(239)
# Simulate Data
###############################################################3
DGPD.alpha <- 0.01
DGPD.beta <- c(1, -0.5, -0.5, -0.1)
DGPD.eta1 <- matrix(rep(DGPD.alpha,n.size), ncol = 1)
DGPD.eta2 <- Xmat%*%DGPD.beta
yy <- r.resp(margin = "DGPII", n.size, eta1 = DGPD.eta1, eta2 = DGPD.eta2)
DGPD.data <- data.frame(y = yy, X = XX)
fmla_degpd1 <- list(lsigma = y ~s(x1)+s(x2)+s(x3), lxi = ~1, lkappa = ~1)
# Classical fit
############################################################
DGPD.classical <- gamlss(form.DGPD, margin = "DGPII", data = DGPD.data)
fmla_degpd1 <- list(lsigma = y ~s(x1)+s(x2)+s(x3), lxi = ~1, lkappa = ~1)
m_degpd1<- devgam(fmla_degpd1, data = DGPD.data, family = "degpd",degpd.args = list(m=1), trace = 2, inits = inits1)
data <- data.frame(y = yy, X = XX)
fmla_degpd1 <- list(lsigma = y ~s(X.x1)+s(X.x2)+s(X.x3), lxi = ~1, lkappa = ~1)
m_degpd1<- devgam(fmla_degpd1, data = DGPD.data, family = "degpd",degpd.args = list(m=1), trace = 2, inits = inits1)
DGPD.classical<- devgam(fmla_degpd1, data = DGPD.data, family = "degpd",degpd.args = list(m=1), trace = 2, inits = inits1)
conv.check(DGPD.classical)
post.check(DGPD.classical)
summary(DGPD.classical)
plot(DGPD.classical, eq = 2, all.terms = TRUE, pages = 1)
plot(DGPD.classical, eq = 1, all.terms = TRUE, pages = 1)
DGPD.AIC <- AIC(DGPD.classical)
DGPD.classical<- devgam(fmla_degpd1, data = DGPD.data, family = "degpd",degpd.args = list(m=1), trace = 2, inits = inits1)
summary(DGPD.classical)
DGPD.AIC <- AIC(DGPD.classical)
plot(DGPD.classical, eq = 1, all.terms = TRUE, pages = 1)
# CaRe (and CIs) computation as a function of x3 (grid on its range)
# (The other covariates are fixed to their mean values)
# p = c(0.86, 0.93, 0.97) for horizon h = (7, 14, 30) days
#####################################################################
newx3 <- data.frame(x1 = rep(mean(x1), length=100),
x2 = rep(mean(x2), length = 100), x3 = seq(min(x3), max(x3), length.out = 100))
CaRe7.classical <- pred.gp(DGPD.classical, p=0.86, newdata = newx3,
n.sim = 250, prob.lev = 0.05)
# CaRe (and CIs) computation as a function of x3 (grid on its range)
# (The other covariates are fixed to their mean values)
# p = c(0.86, 0.93, 0.97) for horizon h = (7, 14, 30) days
#####################################################################
newx3 <- data.frame(x1 = rep(mean(x1), length=100),
x2 = rep(mean(x2), length = 100), x3 = seq(min(x3), max(x3), length.out = 100))
CaRe7.classical <- pred.gp(DGPD.classical, p=0.86, newdata = newx3,
n.sim = 250, prob.lev = 0.05)
source("~/.active-rstudio-document", echo=TRUE)
# CaRe (and CIs) computation as a function of x3 (grid on its range)
# (The other covariates are fixed to their mean values)
# p = c(0.86, 0.93, 0.97) for horizon h = (7, 14, 30) days
#####################################################################
newx3 <- data.frame(x1 = rep(mean(x1), length=100),
x2 = rep(mean(x2), length = 100), x3 = seq(min(x3), max(x3), length.out = 100))
CaRe7.classical <- pred.gp(DGPD.classical, p=0.86, newdata = newx3,
n.sim = 250, prob.lev = 0.05)
# CaRe (and CIs) computation as a function of x3 (grid on its range)
# (The other covariates are fixed to their mean values)
# p = c(0.86, 0.93, 0.97) for horizon h = (7, 14, 30) days
#####################################################################
newx3 <- data.frame(x1 = rep(mean(x1), length=100),
x2 = rep(mean(x2), length = 100), x3 = seq(min(x3), max(x3), length.out = 100))
CaRe7.classical <- pred.gp(DGPD.classical, p=0.86, newdata = newx3,
n.sim = 250, prob.lev = 0.05)
# CaRe (and CIs) computation as a function of x3 (grid on its range)
# (The other covariates are fixed to their mean values)
# p = c(0.86, 0.93, 0.97) for horizon h = (7, 14, 30) days
#####################################################################
newx3 <- data.frame(X.x1 = rep(mean(x1), length=100),
X.x2 = rep(mean(x2), length = 100), X.x3 = seq(min(x3), max(x3), length.out = 100))
CaRe7.classical <- pred.gp(DGPD.classical, p=0.86, newdata = newx3,
n.sim = 250, prob.lev = 0.05)
source("~/.active-rstudio-document", echo=TRUE)
CaRe7.classical <- pred.gp(DGPD.classical, p=0.86, newdata = newx3,
n.sim = 250, prob.lev = 0.05)
###  Real application--------------------------------
setwd("D:/PHD WORK/R Code for PhD work/Discrete Extended GPD/Custom likelihood/Real Applications/EVGAM DEGPD")
path = "" #"C:\\..." # to be completed
source(paste(path,"degpd_pack.r",sep =""))
data <- read.csv("Massif4_movsum.csv")
head(data)
data<-data.frame(data)
inits1<- c(3.0896946, 0.1762738, 0.2)
fmla_degpd1 <- list(lsigma = N_SUM ~s(WS10M_MAX_ME, k=5)+s(T2M_MAX_ME, k=5)+s(PREC_ME, k=5)+s(RH2M_ME, bs="cr"), lxi = ~1, lkappa = ~1)
m_degpd1<- devgam(fmla_degpd1, data = data, family = "degpd",degpd.args = list(m=1), trace = 2, inits = inits1)
summary(m_degpd1)
est_par =predict(m_degpd1)
head(est_par)
plot(m_degpd1)
AIC(m_degpd1)
BIC(m_degpd1)
newdata<- data.frame(WS10M_MAX_ME=data$WS10M_MAX_ME, T2M_MAX_ME=data$T2M_MAX_ME,PREC_ME=data$PREC_ME, RH2M_ME=data$RH2M_ME)
q_degpd1<-predict(m_degpd1,newdata = newdata,  prob = c(0.99))
boxplot(q_degpd1)
mean(q_degpd1$`q:0.99`)
head(est_par)
est_par =predict(m_degpd1, type = 'response')
head(est_par)
est_par =predict(m_degpd1, type = 'response',newdata = newdata)
head(est_par)
plot(m_degpd1)
AIC(m_degpd1)
BIC(m_degpd1)
q_degpd1<-predict(m_degpd1,  prob = c(0.99,0.9966667))
newdata<- data.frame(WS10M_MAX_ME=data$WS10M_MAX_ME, T2M_MAX_ME=data$T2M_MAX_ME,PREC_ME=data$PREC_ME, RH2M_ME=data$RH2M_ME)
q_degpd1<-predict(m_degpd1,newdata = newdata,  prob = c(0.99))
boxplot(q_degpd1)
gev_sim <- simulate(m_degpd1, nsim = 5, newdata = newdata, type = "response")
gev_sim
gev_sim <- simulate(m_degpd1, nsim = 5, newdata = newdata, type = "response")
setwd("D:/DEVGAM/evgam-master/")
dest <- "./R/"
files = list.files(dest, full.names = T)
for (i in 1:length(files)) {
source(files[i])
}
dest <- "./src/"
files = list.files(dest, full.names = T)
for (i in 1:length(files)) {
Rcpp::sourceCpp(files[i])
}
for (i in 1:length(files)) {
source(files[i])
}
dest <- "./src/"
files = list.files(dest, full.names = T)
for (i in 1:length(files)) {
Rcpp::sourceCpp(files[i])
}
newdata<- data.frame(WS10M_MAX_ME=data$WS10M_MAX_ME, T2M_MAX_ME=data$T2M_MAX_ME,PREC_ME=data$PREC_ME, RH2M_ME=data$RH2M_ME)
q_degpd1<-predict(m_degpd1,newdata = newdata,  prob = c(0.99))
gev_sim <- simulate(m_degpd1, nsim = 5, newdata = newdata, type = "response")
gev_sim
setwd("D:/DEVGAM/evgam-master/")
dest <- "./R/"
files = list.files(dest, full.names = T)
for (i in 1:length(files)) {
source(files[i])
}
dest <- "./src/"
files = list.files(dest, full.names = T)
for (i in 1:length(files)) {
Rcpp::sourceCpp(files[i])
}
gev_sim <- simulate(m_degpd1, nsim = 5, newdata = newdata, type = "response")
dest <- "./src/"
files = list.files(dest, full.names = T)
for (i in 1:length(files)) {
Rcpp::sourceCpp(files[i])
}
################DEGPD1
library(mev)
gev_sim <- simulate(m_degpd1, nsim = 5, newdata = newdata, type = "response")
